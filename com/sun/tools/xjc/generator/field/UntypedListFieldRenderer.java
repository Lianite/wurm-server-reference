// 
// Decompiled by Procyon v0.5.30
// 

package com.sun.tools.xjc.generator.field;

import com.sun.codemodel.JVar;
import com.sun.codemodel.JForLoop;
import com.sun.codemodel.JBlock;
import com.sun.codemodel.JMethod;
import com.sun.tools.xjc.generator.JavadocBuilder;
import com.sun.codemodel.JType;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JOp;
import com.sun.codemodel.JClass;
import com.sun.tools.xjc.grammar.FieldUse;
import com.sun.tools.xjc.generator.ClassContext;

public class UntypedListFieldRenderer extends AbstractListFieldRenderer
{
    protected UntypedListFieldRenderer(final ClassContext context, final FieldUse fu, final JClass coreList) {
        super(context, fu, coreList);
    }
    
    public void generateAccessors() {
        final JMethod $get = this.writer.declareMethod((UntypedListFieldRenderer.class$java$util$List == null) ? (UntypedListFieldRenderer.class$java$util$List = class$("java.util.List")) : UntypedListFieldRenderer.class$java$util$List, "get" + this.fu.name);
        this.writer.javadoc().appendComment(this.fu.getJavadoc());
        final JBlock body = $get.body();
        if (this.$defValues != null) {
            final JBlock then = body._if(JOp.cand(this.hasSetValue().not(), this.ref(false).invoke("isEmpty")))._then();
            final JForLoop loop = then._for();
            final JVar $i = loop.init(this.codeModel.INT, "__i", JExpr.lit(0));
            loop.test($i.lt(this.$defValues.ref("length")));
            loop.update($i.incr());
            loop.body().invoke(this.ref(true), "add").arg(this.box((JExpression)this.$defValues.component($i)));
            then.invoke(this.ref(true), "setModified").arg(JExpr.FALSE);
        }
        body._return(this.ref(false));
        this.writer.javadoc().appendComment("Gets the value of the " + this.fu.name + " property.\n\n" + "<p>\n" + "This accessor method returns a reference to the live list,\n" + "not a snapshot. Therefore any modification you make to the\n" + "returned list will be present inside the JAXB object.\n" + "This is why there is not a <CODE>set</CODE> method for the " + this.fu.name + " property.\n" + "\n" + "<p>\n" + "For example, to add a new item, do as follows:\n" + "<pre>\n" + "   get" + this.fu.name + "().add(newItem);\n" + "</pre>\n" + "\n\n");
        this.writer.javadoc().appendComment("<p>\nObjects of the following type(s) are allowed in the list\n" + JavadocBuilder.listPossibleTypes(this.fu));
        if (this.$defValues != null) {
            final JMethod $delete = this.writer.declareMethod((JType)this.codeModel.VOID, "delete" + this.fu.name);
            this.writer.javadoc().setDeprecated("this method is incorrectly generated by previous\nreleases of the RI. This method remains here just to make \nthe generated code backward compatible.\nApplications should <strong>NOT</strong> rely on this method, and\nif it needs this capability, it should use the unset" + this.fu.name + " method.\n" + "To generate the unset" + this.fu.name + " method, please use \n" + "the <code>generateIsSetMethod</code> attribute on\n" + "<code>globalBindings</code> or <code>property</code> customization.");
            this.unsetValues($delete.body());
        }
    }
    
    public static final class Factory implements FieldRendererFactory
    {
        private final JClass coreList;
        
        public Factory(final JClass coreList) {
            this.coreList = coreList;
        }
        
        public FieldRenderer create(final ClassContext context, final FieldUse fu) {
            return (FieldRenderer)new UntypedListFieldRenderer(context, fu, this.coreList);
        }
    }
}
